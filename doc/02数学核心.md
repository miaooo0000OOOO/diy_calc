# 02 数学核心

## 记号

记号是表达式的最小单位，是构成表达式的不可分割的单元。

记号包括以下几类：

1. 操作数：整数，浮点数，变量
2. 一元运算符：负号，函数
3. 二元运算符：加减乘除幂模，等号
4. 运算控制符：左右括号

```c
typedef struct Token
{
    TokenType type; // 枚举 size 1B
    // 内存对齐填补 size 3B
    TokenValue v;   // 共用体 size 4B
} Token; // size 8B
```

## 词法分析器

词法分析器将输入的字符串表达式转化为记号序列，词法分析器是一个状态机，并且可以通过正则表达式（不完全地）描述。

之所以正则表达式无法描述词法规则，是因为其无法检测括号是否匹配，因此我的词法分析器由手工实现，通过将指针指向的字符和上一个字符作为状态机邻接矩阵的行和列来实现词法检查，同时通过栈记录括号是否匹配。

手动实现词法分析器的好处是可以实现灵活的错误处理，方便更改。

该词法分析器实现了词法规则检查，2、8、10、16进制整数和浮点数解析，括号匹配检测，分辨负号（一元运算符）和减号（二元运算符）

## 抽象语法树

抽象语法树是一个有三个指针的结构体，一个指针指向左子树，一个指针指向右子树，一个指针指向其所有的记号

当记号是一个操作数时，左右指针为空。

当记号是一元运算符时，右指针为空。

当记号是二元运算符时，左右都不为空。

## Pratt Parsing

将记号序列转化为抽象语法树的算法为Pratt Parsing，相较于编译原理书中定义项和因子的方式来决定运算符的优先级，Pratt Parsing通过引入约束力的概念，统一了运算符的优先级和结合律，被广泛应用在现代编程语言（如Rust）的表达式解析器中。

[Simple but Powerful Pratt Parsing](https://matklad.github.io/2020/04/13/simple-but-powerful-pratt-parsing.html)


例如

```
expr:      A       +       B       +       C
power:  0  <   3      3.1  >   3      3.1     0
```

在上面的表达式中，左边加号的左约束力为3>0，右约束力3.1>3，因为左边加号的约束力大于两边，所以优先进行运算

即解析为表达式`(A+B)+C`

例二

```
a   +   b   *   c   *   d   +   e
  1   2   3   4   3   4   1   2
```

这个例子中，`b*c`的约束力大于两边因此优先运算

将`b*c`记为f，继续进行约束力比较


```
a   +   f   *   d   +   e
  1   2   3   4   1   2
```

`f*d`的约束力大于两边因此优先运算

最终解析器可以将合法表达式归约为一个操作数，这时抽象语法树的生成便完成了

## 我做的工作

Pratt Parsing的技术博客是由编写Rust解析器的程序员写的，由全英文写成，使用Rust语言编写，我将其改为C语言程序，并且适配本程序的记号定义。

## 递归计算

抽象语法树的计算是一个递归过程，当树节点为操作数时，为基本条件；当树节点为运算符节点时，为递归条件。

基本条件中，会将变量转化为浮点数，并参与计算。递归条件中，会根据操作数的类型多态地运算，并返回一个操作数。因此，合法的抽象语法树一定能被归约为一个操作数作为结果。

## 多态计算

在32位计算机系统中，有符号整数的表达范围为`-2^31'~2^31`，有十位十进制有效数字，而浮点数的表示范围为十进制7位有效数字，其中第七位不一定有效。

可见如果一个数字是整数，使用整型存储和计算能提升表达范围，加快计算速度。

多态计算中，先判断数据类型，再分支到不同的处理函数，即可实现多态计算。

## 解方程方法的选择

解方程的方法有三种：

1. 多项式方程中，<=4次方程可以用公式解出复数域内的所有解析解，>4次方程可以用试根法有可能解出复数域内的所有数值解
2. 非多项式方程，使用牛顿迭代法，可能解出实数域内的一个解
3. 非多项式方程，使用二分法，可能解出实数域内的一个解

这三种方法中，方法一需要将抽象语法树转化为方程系数数列，较麻烦。方法二需要求导，自动求导较精确，但自动求导基于求导的链式法则，编程较麻烦；差分求导的精度不够。因此，解方程的方法最终选择使用二分法。

## 二分法解方程的实现

方程等号左边减等号右边记为f(x)，解方程即求x使f(x)=0

寻根区间左端点记为l，右端点r

输入寻根区间和方程的抽象语法树，首先判断f(l)*f(r)是否<0，若同号，则在寻根区间内寻找一点r_，使f(l)*f(r_)<0，并令r=r_

寻找r_时，首先以(r-l)/2为步长递归，若未找到，则再以(r-l)/4为步长递归，以此类推，以(r-l)/(2^n)为步长递归，直到f(l)*f(r_)<0

异号之后，令m=(l+r)/2，若f(l)*f(m)<0，则r=m，否则令l=m，当abs(f(m))<容许误差时，返回解x=m


