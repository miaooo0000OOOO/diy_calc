# 05 测试调试和内存分析

## 使用openocd+vscode进行调试

openocd是开源的调试软件，使用vscode的cortex-debug可以现代化地调试

其可以添加断点，在程序遇到断点停止后查看和修改变量和寄存器的值


## 进行单元测试和集成测试

对于一个不大的程序，编写专门的测试单元较麻烦，但是依然可以通过断点调试的方法对模块的行为进行测试，检查其是否符合预期行为。

储存库中的集成测试测试了计算器的所有功能，同时也是计算器使用的良好参考

## 动态内存分析

在程序运行过程中，会使用`malloc`进行动态内存分配以存储抽象语法树。

如果动态内存没有在使用后及时释放，就会导致堆区可用内存不断减少，最后到达无内存可用的地步。

然而手动管理动态内存可能导致内存泄漏和二次释放错误，因此，在应代码中使用良好的设计模式并且搭配内存分析工具来减少动态内存漏洞。

## 所有权与引用

一个变量负责一块堆上的动态内存，则称这个变量拥有该内存区域的所有权。当该变量的生命周期结束时，释放该动态内存。

如果不使用计数指针，那么一块内存区域只能被一个变量所有，这样就能保证该内存一定被释放且只被释放一次。

所有权可以从一个变量移动到另一个变量，或者通过引用被其他变量借用。

引用不拥有变量的所有权，一个变量要么有一个可变引用，要么有多个不可变引用。

例如

```C
AST_Node *solve_dichotomy(const AST_Node *const node, const Token *const left_x, const Token *const right_x) // 二分法解方程
```

其中的`node`就是一个不可变引用，`solve_dichotomy`函数只读取`node`，不修改也不释放其内存。

其返回一个有所有权的抽象语法树，这意味着函数的调用者要负责释放函数的返回值所指向的动态内存。

## 内存分析工具

在软件部分的Makefile中的CFLAGS中打开选项:`-fsanitize=address -fno-omit-frame-pointer`，即可使用AddressSanitizer进行动态内存分析。

在程序运行结束后，AddressSanitizer会检查程序运行过程中的内存泄漏和二次释放

例如写一个会内存泄漏的释放抽象语法树的代码：

```C
void deep_free_ast(const AST_Node *const node)
{
    if (node == NULL)
        return;
    if (node->token != NULL)
        free(node->token);
    deep_free_ast(node->right);
    free(node->right);
    deep_free_ast(node->left);
    free(node->left);
}
```

运行该代码并结束程序，AddressSanitizer输出分析结果如下：

```
> ./bin/main
>>> 1+1
Int(2)
>>> 
exited

=================================================================
==11102==ERROR: LeakSanitizer: detected memory leaks

Direct leak of 24 byte(s) in 1 object(s) allocated from:
    #0 0x7fc98acdefef in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:69
    #1 0x562174bc9765 in copy_node src/ast.c:223
    #2 0x562174bcc6e6 in recu_calc src/calculation.c:461
    #3 0x562174bcc720 in recu_calc src/calculation.c:463
    #4 0x562174bcc881 in calc src/calculation.c:482
    #5 0x562174bce68e in main src/main.c:103
    #6 0x7fc98a823a8f in __libc_start_call_main ../sysdeps/nptl/libc_start_call_main.h:58
略
```

报错如上

改成有二次释放漏洞的代码

```C
void deep_free_ast(const AST_Node *const node)
{
    if (node == NULL)
        return;
    if (node->token != NULL)
        free(node->token);
    deep_free_ast(node->right);
    free(node->right);
    deep_free_ast(node->left);
    free(node->left);
    free(node);
}
```

报错如下

```
上略
==11495==ERROR: AddressSanitizer: attempting double-free on 0x603000000070 in thread T0:
下略
```

可见AddressSanitizer可有效定位动态内存漏洞并判断漏洞类型，有助于修复动态内存漏洞