# 00 计算示例

    ! 错误算式不会显示结果且无提示
    ! 解方程时搜索空间超出定义域会出现错误结果

    整数四则运算
    >>> 1+1
    Int(2)

    >>> 3-2
    Int(1)

    >>> 3*3
    Int(9)

    >>> 8/4
    Int(2)

    >>> -5-7
    Int(-12)

    浮点数四则运算
    >>> 1.5+0.9
    Float(2.400000)

    >>> 9.9-8.8
    Float(1.099999)

    >>> 0.4*0.5
    Float(0.200000)

    >>> 1/3
    Float(0.333333)

    >>> 1.9/0.5
    Float(3.800000)

    幂运算
    >>> 2^10
    Int(1024)

    >>> 2^0.5
    Float(1.414214)

    >>> (-1)^10
    Int(1)

    >>> 9^0
    Int(1)

    >>> 0.1234^3.5
    Float(0.000660)

    >>> 9^(-0.5)
    Float(0.333333)

    模运算

    >>> 9%3
    Int(0)

    >>> 1919810%114514
    Int(87586)

    >>> (-90)%360
    Int(-90)

    >>> (-90)%(-360)
    Int(-90)

    >>> 1919.810%114.514
    Float(87.586060)

    进制输入

    二进制
    >>> 0b1010  
    Int(10)

    十六进制
    >>> 0xabcdef
    Int(11259375)

    八进制
    >>> 0367
    Int(247)

    >>> 0b101001101+0xfa9-0777
    Int(3831)

    >>> 0b10^0b1010
    Int(1024)

    括号嵌套、优先级与结合性

    >>> 10*(2-9)
    Int(-70)

    >>> 10*(8/(7*6)-3%2) 
    Float(-8.095238)

    >>> 4^3^2
    Int(262144)

    >>> (4^3)^2
    Int(4096)

    函数

    平方根
    >>> sqrt(2)
    Float(1.414214)

    >>> sqrt(81)
    Int(9)

    对数函数
    >>> ln(2.71828)  
    Float(0.999999)

    >>> ln(7.389056)
    Float(2.000000)

    >>> ln(0.3678794)
    Float(-1.000000)

    >>> ln(1)
    Float(0.000000)

    >>> log(100)
    Float(2.000000)

    >>> log(0.1)
    Float(-1.000000)

    >>> log(1234)
    Float(3.091315)

    三角函数(弧度制)
    >>> sin(3.141593)
    Float(-0.000000)

    >>> sin(0)
    Float(0.000000)

    >>> cos(3.141593)
    Float(-1.000000)

    >>> tan(1.570796)
    Float(3185560.750000)

    >>> cot(1.57)     
    Float(0.000796)

    解方程(二分法)
    >>> x^2=1
    请输入
    left x:-10
    right x:10
    有一解为
    x=-1.000000
    误差为
    abs(left-right): 0.000000

    >>> 5*x^3+9*x-9=9
    请输入
    left x:-100
    right x:100
    有一解为
    x=1.151581
    误差为
    abs(left-right): 0.000002

    >>> 3*x=9
    请输入
    left x:-10
    right x:10
    有一解为
    x=3.000000
    误差为
    abs(left-right): 0.000000

    >>> ln(x)=1
    请输入
    left x:0.001
    right x:10
    有一解为
    x=2.718282
    误差为
    abs(left-right): 0.000000

    >>> sin(x)=0
    请输入
    left x:1
    right x:10
    有一解为
    x=3.141593
    误差为
    abs(left-right): 0.000000

    >>> ln(x)+sin(x)^2=2
    请输入
    left x:0.1
    right x:10
    有一解为
    x=4.033223
    误差为
    abs(left-right): 0.000000

# 01 总体设计

## 设计要求

    主要功能：
    1.学习屏幕图形图案的绘制和字库的覆写，在屏幕上输出相应的内容。
    2.计算器可以完成简单的初等运算，并且运算时参照数学上的运算优先级。
    3.完善计算器细节的处理，如小数运算、负号和减号的区分等。

    辅助功能：
    1.学习启发式算法、设计能解出方程的至少一个根的算法。
    2.使用头文件<math.h>来设计数学中常用的三角、指对运算等。
    3.括号具有尽可能多的嵌套层数，最好可以无限制嵌套。
    
    发挥部分：
    1.增加计算器的拓展功能，如初等/高等数学常用的算符、算子。
    2.自行设计更多与计算器主题相符的功能。

## 根据设计要求所作的硬件选型

该项目采用一块触摸屏作为其输入输出设备，我认为有以下好处：

1. 可拓展性强，可以灵活变更界面布局
2. 显示效果好，色彩丰富，显示区域大
3. 硬件高度集成，便于设计外壳

该触摸屏有助于13个引脚，不便于使用杜邦线连接，为了系统稳定运行，我设计了一块插件PCB

综上，该项目的全部硬件包括：

1. STM32F103RCT6开发板
2. 自己画的插件PCB
3. 触摸屏模块

## 软件架构

该系统的软件包括：图形用户界面，显示屏驱动，字库和图形库，数学核心

### 图形用户界面的设计与实现

图形用户界面由显示区域和键盘区域组成，键盘布局参考卡西欧科学计算器的键盘布局，显示区域和键盘区域占比设计也主要参考卡西欧科学计算器。

GUI模块使用结构体定义了显示控件，包括屏幕控件`ShowScreen`和按钮控件`BUTTON4048`，实现了光标移动输入删除，按钮按下变色，按钮按下边沿触发。

使用GUI控件实现了局部动态刷新屏幕，提高了屏幕使用流畅度

### 显示屏驱动的改写

显示屏驱动由厂商提供，使用底层库，MDK工程，Windows操作系统开发，我将其改写为兼容HAL库和底层库的Makefile工程，使用Linux Ubuntu系统开发，可以使用STM32CubeMX配置。

在此，我简单介绍一下Linux嵌入式开发工具链：

    STM32CubeMX配置工程，选择使用Makefile编译工程

    使用arm-none-eabi-gcc交叉编译，主机平台x86_64，目标平台arm

    使用Makefile管理C项目

    使用vscode编程和调试

    使用openocd烧录

    使用gdb-multiarch和vscode上的cortex-debug拓展进行调试

为了移植触摸屏驱动，我做了以下工作：

1. 将底层库初始化的时钟，GPIO输入输出，硬件SPI配置移植到CubeMX上
2. 解决依赖问题和命名冲突
3. 理解触摸屏驱动原理，对性能要求较高的SPI读写依然保留了底层库，而其他部分使用了HAL库，兼具性能和开发效率
4. Windows使用GBK编码，Linux使用UTF-8编码，将GBK编码的字库驱动改为UTF-8的字库驱动
5. 对CubeMX生成的Makefile文件作出修改，管理编译依赖，生成可调试的二进制程序

## 字库和图形库的改写

Windows使用GBK编码，Linux使用UTF-8编码，一个GBK中文字符占2字节，一个UTF-8中文占3字节，因此移植过程中将UTF-8的字符比较改为3字节。

图形库由厂商提供，非常好用，没改。

## 数学核心的总体设计

参考编译原理的相关知识，输入字符串输出记号序列，输入记号序列输出抽象语法树，递归计算抽象语法树得出计算结果。

另一种实现方式是将表达式转化为后缀表达式，并使用栈进行计算，我认为这种方式的可拓展性不如抽象语法树。

将字符串转化为记号序列称为词法分析，将记号序列转化为抽象语法树称为解析

具体实现详见数学核心的文档# 02 数学核心

## 记号

记号是表达式的最小单位，是构成表达式的不可分割的单元。

记号包括以下几类：

1. 操作数：整数，浮点数，变量
2. 一元运算符：负号，函数
3. 二元运算符：加减乘除幂模，等号
4. 运算控制符：左右括号

        typedef struct Token
        {
            TokenType type; // 枚举 size 1B
            // 内存对齐填补 size 3B
            TokenValue v;   // 共用体 size 4B
        } Token; // size 8B

## 词法分析器

词法分析器将输入的字符串表达式转化为记号序列，词法分析器是一个状态机，并且可以通过正则表达式（不完全地）描述。

之所以正则表达式无法描述词法规则，是因为其无法检测括号是否匹配，因此我的词法分析器由手工实现，通过将指针指向的字符和上一个字符作为状态机邻接矩阵的行和列来实现词法检查，同时通过栈记录括号是否匹配。

手动实现词法分析器的好处是可以实现灵活的错误处理，方便更改。

该词法分析器实现了词法规则检查，2、8、10、16进制整数和浮点数解析，括号匹配检测，分辨负号（一元运算符）和减号（二元运算符）

## 抽象语法树

抽象语法树是一个有三个指针的结构体，一个指针指向左子树，一个指针指向右子树，一个指针指向其所有的记号

当记号是一个操作数时，左右指针为空。

当记号是一元运算符时，右指针为空。

当记号是二元运算符时，左右都不为空。

## Pratt Parsing

将记号序列转化为抽象语法树的算法为Pratt Parsing，相较于编译原理书中定义项和因子的方式来决定运算符的优先级，Pratt Parsing通过引入约束力的概念，统一了运算符的优先级和结合律，被广泛应用在现代编程语言（如Rust）的表达式解析器中。

[Simple but Powerful Pratt Parsing]
(https://matklad.github.io/2020/04/13/simple-but-powerful-pratt-parsing.html)


例如

    expr:      A       +       B       +       C
    power:  0  <   3      3.1  >   3      3.1     0

在上面的表达式中，左边加号的左约束力为3>0，右约束力3.1>3，因为左边加号的约束力大于两边，所以优先进行运算

即解析为表达式`(A+B)+C`

例二

    a   +   b   *   c   *   d   +   e
    1   2   3   4   3   4   1   2

这个例子中，`b*c`的约束力大于两边因此优先运算

将`b*c`记为f，继续进行约束力比较

    a   +   f   *   d   +   e
    1   2   3   4   1   2

`f*d`的约束力大于两边因此优先运算

最终解析器可以将合法表达式归约为一个操作数，这时抽象语法树的生成便完成了

## 我做的工作

Pratt Parsing的技术博客是由编写Rust解析器的程序员写的，由全英文写成，使用Rust语言编写，我将其改为C语言程序，并且适配本程序的记号定义。

## 递归计算

抽象语法树的计算是一个递归过程，当树节点为操作数时，为基本条件；当树节点为运算符节点时，为递归条件。

基本条件中，会将变量转化为浮点数，并参与计算。递归条件中，会根据操作数的类型多态地运算，并返回一个操作数。因此，合法的抽象语法树一定能被归约为一个操作数作为结果。

## 多态计算

在32位计算机系统中，有符号整数的表达范围为`-2^31'~2^31`，有十位十进制有效数字，而浮点数的表示范围为十进制7位有效数字，其中第七位不一定有效。

可见如果一个数字是整数，使用整型存储和计算能提升表达范围，加快计算速度。

多态计算中，先判断数据类型，再分支到不同的处理函数，即可实现多态计算。

## 解方程方法的选择

解方程的方法有三种：

1. 多项式方程中，<=4次方程可以用公式解出复数域内的所有解析解，>4次方程可以用试根法有可能解出复数域内的所有数值解
2. 非多项式方程，使用牛顿迭代法，可能解出实数域内的一个解
3. 非多项式方程，使用二分法，可能解出实数域内的一个解

这三种方法中，方法一需要将抽象语法树转化为方程系数数列，较麻烦。方法二需要求导，自动求导较精确，但自动求导基于求导的链式法则，编程较麻烦；差分求导的精度不够。因此，解方程的方法最终选择使用二分法。

## 二分法解方程的实现

方程等号左边减等号右边记为f(x)，解方程即求x使f(x)=0

寻根区间左端点记为l，右端点r

输入寻根区间和方程的抽象语法树，首先判断f(l)*f(r)是否<0，若同号，则在寻根区间内寻找一点r_，使f(l)*f(r_)<0，并令r=r_

寻找r_时，首先以(r-l)/2为步长递归，若未找到，则再以(r-l)/4为步长递归，以此类推，以(r-l)/(2^n)为步长递归，直到f(l)*f(r_)<0

异号之后，令m=(l+r)/2，若f(l)*f(m)<0，则r=m，否则令l=m，当abs(f(m))<容许误差时，返回解x=m

# 03 图形用户界面的实现

## 按钮的局部动态刷新

若按钮按下时，pressed属性不为真，则说明其为按下边沿，使pressed为真，edge为真

edge当按钮上升沿时为真，edge为真，则需要刷新button，刷新后将edge设为假

## 屏幕控件的实现

屏幕分为一二三行，每一行有最大输入长度，每行可以单独刷新

为了实现光标移动输入，使用`string.h`库，实现字符串插入、删除操作

使用`memmove`、`memset`和`strcpy`函数，其相较使用for循环速度更快，可读性强。用`memmove`拷贝可以处理内存重叠的情况


# 04 符号表与变量

## 变量的存储和表示

一个变量包括变量名，变量类型和变量的值。

当变量第一次出现在一个表达式中时，会将变量添加到符号表中，其类型为`未定义`。当变量赋值时，会确定变量的类型和值。在重新赋值时可以改变类型。

## 变量的应用

变量x在方程中代表未知数，首先对x进行赋值，并且代入方程进行计算。

常量e，pi在程序开始时定义和赋值。
# 05 测试调试和内存分析

## 使用openocd+vscode进行调试

openocd是开源的调试软件，使用vscode的cortex-debug可以现代化地调试

其可以添加断点，在程序遇到断点停止后查看和修改变量和寄存器的值


## 进行单元测试和集成测试

对于一个不大的程序，编写专门的测试单元较麻烦，但是依然可以通过断点调试的方法对模块的行为进行测试，检查其是否符合预期行为。

储存库中的集成测试测试了计算器的所有功能，同时也是计算器使用的良好参考

## 动态内存分析

在程序运行过程中，会使用`malloc`进行动态内存分配以存储抽象语法树。

如果动态内存没有在使用后及时释放，就会导致堆区可用内存不断减少，最后到达无内存可用的地步。

然而手动管理动态内存可能导致内存泄漏和二次释放错误，因此，在应代码中使用良好的设计模式并且搭配内存分析工具来减少动态内存漏洞。

## 所有权与引用

一个变量负责一块堆上的动态内存，则称这个变量拥有该内存区域的所有权。当该变量的生命周期结束时，释放该动态内存。

如果不使用计数指针，那么一块内存区域只能被一个变量所有，这样就能保证该内存一定被释放且只被释放一次。

所有权可以从一个变量移动到另一个变量，或者通过引用被其他变量借用。

引用不拥有变量的所有权，一个变量要么有一个可变引用，要么有多个不可变引用。

例如

    AST_Node *solve_dichotomy(
        const AST_Node *const node,
        const Token *const left_x,
        const Token *const right_x
        ) // 二分法解方程

其中的`node`就是一个不可变引用，`solve_dichotomy`函数只读取`node`，不修改也不释放其内存。

其返回一个有所有权的抽象语法树，这意味着函数的调用者要负责释放函数的返回值所指向的动态内存。

## 内存分析工具

在软件部分的Makefile中的CFLAGS中打开选项:`-fsanitize=address -fno-omit-frame-pointer`，即可使用AddressSanitizer进行动态内存分析。

在程序运行结束后，AddressSanitizer会检查程序运行过程中的内存泄漏和二次释放

例如写一个会内存泄漏的释放抽象语法树的代码：

    void deep_free_ast(const AST_Node *const node)
    {
        if (node == NULL)
            return;
        if (node->token != NULL)
            free(node->token);
        deep_free_ast(node->right);
        free(node->right);
        deep_free_ast(node->left);
        free(node->left);
    }

运行该代码并结束程序，AddressSanitizer输出分析结果如下：

    > ./bin/main
    >>> 1+1
    Int(2)
    >>> 
    exited

    =================================================================
    ==11102==ERROR: LeakSanitizer: detected memory leaks

    Direct leak of 24 byte(s) in 1 object(s) allocated from:
        #0 0x7fc98acdefef in __interceptor_malloc \
        ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:69
        #1 0x562174bc9765 in copy_node src/ast.c:223
        #2 0x562174bcc6e6 in recu_calc src/calculation.c:461
        #3 0x562174bcc720 in recu_calc src/calculation.c:463
        #4 0x562174bcc881 in calc src/calculation.c:482
        #5 0x562174bce68e in main src/main.c:103
        #6 0x7fc98a823a8f in __libc_start_call_main \
        ../sysdeps/nptl/libc_start_call_main.h:58
    略

报错如上

改成有二次释放漏洞的代码

    void deep_free_ast(const AST_Node *const node)
    {
        if (node == NULL)
            return;
        if (node->token != NULL)
            free(node->token);
        deep_free_ast(node->right);
        free(node->right);
        deep_free_ast(node->left);
        free(node->left);
        free(node);
    }

报错如下

    上略
    ==11495==ERROR: AddressSanitizer:\
    attempting double-free on 0x603000000070 in thread T0:
    下略

可见AddressSanitizer可有效定位动态内存漏洞并判断漏洞类型，有助于修复动态内存漏洞

## 06 源代码储存库

https://github.com/miaooo0000OOOO/diy_calc

注：用户名为3个英文小写o，4个零，四个英文大写O